//
// Edifact.cs
//
// This file was generated by MapForce 2023sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//

using System;
using System.Globalization;
using System.Collections;
using System.Text.RegularExpressions;
using Altova.Types;

namespace Altova.Functions 
{
	public class Edifact
	{

		#region datetime functions
		/// <summary> 
		/// result = datetime + duration
		/// Performs a addition of dates, times and durations.
		/// </summary>
		

		//The result is the date value extracted from the coded source using the given format code.
		public static Altova.Types.DateTime ToDate(string sValue, string sFormat) 
		{
			return Edifact.ToDate(sValue, sFormat, true);
		}

		//Overloaded method with control parameter for the default exception (bRaiseExc)
		private static Altova.Types.DateTime ToDate(string sValue, string sFormat, bool bRaiseExc) 
		{
			Altova.Types.DateTime result = null;

			int century = 0;
			int year = 0;
			int month = 0;
			int week = 0;
			int day = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// DDMMYY
				case 2:
				{
					CheckLength(sValue, sFormat, 6);
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;

				// MMDDYY
				case 3:
				{
					CheckLength(sValue, sFormat, 6 );
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;

				// DDMMCCYY
				case 4:
				{
					CheckLength(sValue, sFormat, 8);
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;


				// CCYYMMB
				// B=1:first half month, B=2:second half month.
				case 6:
				{
					CheckLength(sValue, sFormat, 7 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int B	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, 1 );
					Altova.Types.Duration offset = new Altova.Types.Duration( 0, 0, 15, 0, 0, 0, 0.0, false );
					result = B == 2 ? Lang.DatetimeAdd( date, offset ) : date;
				}
					break;
		
				// CCYYMMW
				// W=1-5 first week to fifth week in a month.
				case 7:
				{
					CheckLength(sValue, sFormat, 7 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					week	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime baseDate = new Altova.Types.DateTime( Y2KConvert.Year( century, year), month, 1 );
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
					result	= Lang.DatetimeAdd( baseDate, days );
				}
					break;
		
				// CCYYMMDDS
				// Shift within a calendar day: CC=century YY=year MM=month DD=day S=1-9 shift in a day.
				case 8:
				{
					CheckLength(sValue, sFormat, 9 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int s	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;
					
				// CCYYMMDDPP
				// Time period within a calendar day: CC=century YY=year MM=month DD=day PP=00-99 time period.
				case 9:
				{
					CheckLength(sValue, sFormat, 10 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int pp	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;

				// YYMMDD
				// Calendar date: Y = Year; M = Month; D = Day.
				case 101:
				{
					CheckLength(sValue, sFormat, 6 );
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;
		
				// CCYYMMDD
				// Calendar date: C = Century ; Y = Year ; M = Month ; D = Day.
				case 102:
				{
					CheckLength(sValue, sFormat, 8 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;
		
				// YYWWD
				// Calendar week day: Y = Year ; W = Week ; D = Day 
				// Week number 01 is always first week of January 
				// Day number 1 is always Monday.
				case 103:
				{
					CheckLength(sValue, sFormat, 5 );
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					week	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( year ), 1, 4 );
					int weekDay = (int) date.Value.DayOfWeek;	// sunday = 0
					weekDay = (weekDay + 6) % 7;				// monday = 0
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week - 1) * 7 + day - 1 - weekDay, 0, 0, 0, 0.0, false );

					result = Lang.DatetimeAdd( date, days );
				}
					break;
		
				// YYDDD
				// Calendar day: Y = Year ; D = Day 
				// January the first = Day 001 
				// Always start numbering the days of the year from January 1st through December 31st.
				case 105:
				{
					CheckLength(sValue, sFormat, 5);
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 3 ) );	i += 3;
					Altova.Types.DateTime baseDate = new Altova.Types.DateTime( Y2KConvert.Year( year ), 1, 1 ); // January 1st 
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, day-1, 0, 0, 0, 0.0, false );
					result	= Lang.DatetimeAdd( baseDate, days );
				}
					break;
		
				//YYWW
				// Week within a calendar year: Y = Year; W = Week 1st week of January = week 01.
				case 615:
				{
					CheckLength ( sValue, sFormat, 4 );
					year = Convert.ToInt32( new String( arrValue, i, 2 ) ); i += 2;
					week = Convert.ToInt32( new String( arrValue, i, 2 ) ); i += 2;

					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( year ), 1, 4 );
					int weekDay = (int) date.Value.DayOfWeek;	// sunday = 0
					weekDay = (weekDay + 6) % 7;				// monday = 0
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week - 1) * 7 - weekDay, 0, 0, 0, 0.0, false );

					result = Lang.DatetimeAdd( date, days );
				}
					break;
					
				// CCYYWW
				// Week within a calendar year: CC = Century; Y = Year; W = Week (1st week of January = week 01).
				case 616:
				{
					CheckLength ( sValue, sFormat, 6 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) ); i += 2;
					year = Convert.ToInt32( new String( arrValue, i, 2 ) ); i += 2;
					week = Convert.ToInt32( new String( arrValue, i, 2 ) ); i += 2;

					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( century, year ), 1, 4 );
					int weekDay = (int) date.Value.DayOfWeek;	// sunday = 0
					weekDay = (weekDay + 6) % 7;				// monday = 0
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week - 1) * 7 - weekDay, 0, 0, 0, 0.0, false );

					result = Lang.DatetimeAdd( date, days );
				}
					break;
			
				default:
				{
					if ( bRaiseExc )throw new ConversionException("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'");
				}
					break;
			}
			return result;
		}

		//The result is the time value extracted from the coded source using the given format code.
		public static Altova.Types.DateTime ToTime(string sValue, string sFormat)
		{
			return Edifact.ToTime( sValue, sFormat, true );
		}

		//Overloaded method with control parameter for the default exception (bRaiseExc)
		private static Altova.Types.DateTime ToTime(string sValue, string sFormat, bool bRaiseExc)
		{
			Altova.Types.DateTime result = null;

			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// HHMM
				// Time without seconds: H = Hour; m = Minute.
				case 401:
				{
					CheckLength(sValue, sFormat, 4 );
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, hour, minute, 0.0 );
				}
				break;
	
				// HHMMSS
				// Time with seconds: H = Hour; m = Minute; s = Seconds.
				case 402:
				{
					CheckLength(sValue, sFormat, 6 );
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, hour, minute, seconds );
				}
					break;
		
				// HHMMSSZZZ
				// See 402 plus Z=Time zone.
				case 404:
				{
					CheckMinMaxLength(sValue, sFormat, 7, 9 );
					string tz;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					tz		= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result = new Altova.Types.DateTime( 1, 1, 1, hour, minute, seconds, TZConvert.Timezone( tz ) );
				}
				break;
		
				// MMMMSS
				// Time without hours: m=minutes, s=seconds.
				case 405:
				{
					CheckLength(sValue, sFormat, 6 );
					minute	= Convert.ToInt32( new String( arrValue, i, 4 ) );	i += 4;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, minute / 60, minute % 60, seconds );
				}
				break;
		
				default:
				{
					if ( bRaiseExc )throw new ConversionException("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'");
				}
				break;
			}

			return result;
		}

		//The result is the datetime value extracted from the coded source using the given format code.
		public static Altova.Types.DateTime ToDatetime(string sValue, string sFormat)
		{
			return Edifact.ToDatetime( sValue, sFormat, true );
		}

		//Overloaded method with control parameter for the default exception (bRaiseExc)
		private static Altova.Types.DateTime ToDatetime(string sValue, string sFormat, bool bRaiseExc)
		{
			Altova.Types.DateTime result = null;

			int century = 0;
			int year = 0;
			int month = 0;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// DDMMCCYYHHMM
				case 5:		
				{
					CheckLength(sValue, sFormat, 12 );
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
				break;

				// CCYYMMDDTHHMM
				// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; T=Time designator; H=Hour; M=Minutes.
				// The character [T] shall be used as time designator to indicate the start of the representation of the time.
				// For example: 20010912T1433.
				case 10:
				{
					CheckLength(sValue, sFormat, 13 );
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					char T	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
				break;

				// YYMMDDHHMM
				// Calendar date including time without seconds: Y = Year; M = Month; D = Day; H = Hour; M = Minute.
				case 201:
				{
					CheckLength(sValue, sFormat, 10 );
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, 0 );
				}
					break;

				// YYMMDDHHMMSS
				// Calendar date including time with seconds: Y = Year; M = Month; D = Day; H = Hour; m = Minutes = Seconds.
				case 202:
				{
					CheckLength(sValue, sFormat, 12 );
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, seconds );
				}
					break;
		
				// CCYYMMDDHHMM
				// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; H=Hour; M=Minutes.
				case 203:
				{
					CheckLength(sValue, sFormat, 12 );
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
					break;

				// CCYYMMDDHHMMSS
				// Calendar date including time with seconds: C=Century;Y=Year; M=Month;D=Day;H=Hour;M=Minute;S=Second.
				case 204:
				{
					CheckLength(sValue, sFormat, 14 );
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, seconds );
				}
					break;

				// CCYYMMDDHHMMZHHMM
				// Calendar date including time and time zone expressed in hours and minutes.
				// ZHHMM = time zone given as offset from Coordinated Universal Time (UTC).
				case 205:
				{
					CheckLength(sValue, sFormat, 17 );
					int offsetH = 0;
					int offsetM = 0;

					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					char s	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					offsetH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					offsetM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int tz = ( offsetH * 60 + offsetM ) * ((s == '-') ? -1 : +1);
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, tz );
				}
					break;

				// YYMMDDHHMMZZZ
				// See 201 + Z = Time zone.
				case 301:
				{
					CheckMinMaxLength(sValue, sFormat, 11, 13 );
					string zone;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, 0, TZConvert.Timezone( zone ) );
				}
					break;
		
				// YYMMDDHHMMSSZZZ
				// See 202 + Z = Time zone.
				case 302:
				{
					CheckMinMaxLength(sValue, sFormat, 13, 15);
					string zone;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, seconds, TZConvert.Timezone( zone ) );
				}
					break;
		
				// CCYYMMDDHHMMZZZ
				// See 203 plus Z=Time zone.
				case 303:
				{
					CheckMinMaxLength(sValue, sFormat, 13, 15 );
					string zone;
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, TZConvert.Timezone( zone ) );
				}
					break;
		
				// CCYYMMDDHHMMSSZZZ
				// See 204 plus Z=Time zone.
				case 304:
				{
					CheckMinMaxLength(sValue, sFormat, 15, 17);
					string zone;
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, seconds, TZConvert.Timezone( zone ) );
				}
					break;

				default:
				{
					if ( bRaiseExc )throw new ConversionException("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'");
				}
				break;
			}
			return result;
		}

		//The result is the duration value extracted from the coded source using the given format code.
		public static Altova.Types.Duration ToDuration(string sValue, string sFormat)
		{
			return Edifact.ToDuration( sValue, sFormat, true );
		}

		//Overloaded method with control parameter for the default exception (bRaiseExc)
		private static Altova.Types.Duration ToDuration(string sValue, string sFormat, bool bRaiseExc)
		{
			sValue = sValue.Replace("-", "");
			Altova.Types.Duration result = null;

			int year = 0;
			int month = 0;
			int week = 0;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// MMDD
				// Day of a month: M = Month; D = Day.
				case 106:
				{
					CheckLength(sValue, sFormat, 4 );
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result = new Altova.Types.Duration( 0, month, day, 0, 0, 0, 0.0, false );
					//result	= new Altova.Types.DateTime( 1, month, day );
				}
					break;
				// MMDDHHMM
				// Month, day, hours, minutes; M = Month; D = Day; H = Hour; M = Minute.
				case 305:
				{
					CheckLength(sValue, sFormat, 8);
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, month, day, hour, minute, 0, 0.0, false );
				}
					break;
	
				// DDHHMM
				// Day, hours, minutes; D = Day; H = Hour; M = Minute.
				case 306:
				{	
					CheckLength(sValue, sFormat, 6 );
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, 0, day, hour, minute, 0, 0.0, false );
				}
					break;

				// ZHHMM
				// Offset from Coordinated Universal Time (UTC) where Z is plus (+) or minus (-).
				case 406:	
				{
					CheckLength(sValue, sFormat, 5 );
					char s	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, 0, 0, hour, minute, 0, 0.0, s == '-' );
				}
					break;

				// HHMMHHMM
				// Time span without seconds: H = Hour; m = Minute;.
				case 501:
				{
					CheckLength(sValue, sFormat, 8 );
					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// HHMMSS-HHMMSS
				// A period of time specified by giving the start time
				// followed by the end time (both expressed by hours
				// minutes and seconds). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 502:	
				{	
					CheckLength(sValue, sFormat, 12 );
					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, fromS );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, toS );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// HHMMSSZZZ-HHMMSSZZZ
				// A period of time specified by giving the start time
				// followed by the end time (both expressed by hours
				// minutes, seconds and time zone). Data is to be
				// transmitted as consecutive characters without hyphen.
				case 503:
				{
					CheckMinMaxLength(sValue, sFormat, 14, 18 );
					string fromZ, toZ;

					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					fromZ		= Convert.ToString(new String( arrValue, i, 3 ) );	i += 3;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					toZ			= Convert.ToString(new String( arrValue, i, 3 ) );	i += 3;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, fromS, TZConvert.Timezone( fromZ ) );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, toS, TZConvert.Timezone( toZ ) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// YY-YY
				// A period of time specified by giving the start year
				// followed by the end year (both without century). Data is
				// to be transmitted as consecutive characters without
				// hyphen.
				case 701:
				{
					CheckLength(sValue, sFormat, 4 );
					int fromY	= Y2KConvert.Year( Convert.ToInt32( new String( arrValue, i, 2 ) ) );	i += 2;
					int toY		= Y2KConvert.Year( Convert.ToInt32( new String( arrValue, i, 2 ) ) );	i += 2;
					result 		= new Altova.Types.Duration( toY - fromY, 0, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYY-CCYY
				// A period of time specified by giving the start year
				// followed by the end year (both including century). Data
				// is to be transmitted as consecutive characters without hyphen.
				case 702:
				{
					CheckLength(sValue, sFormat, 8 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					fromY = Y2KConvert.Year( fromC, fromY );
					toY = Y2KConvert.Year( toC, toY );

					result = new Altova.Types.Duration( toY - fromY, 0, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// YYS-YYS
				// A period of time specified by giving the start semester
				// of a year followed by the end semester of a year (both
				// not including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 703:
				{
					CheckLength(sValue, sFormat, 6 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromY );
					toY = Y2KConvert.Year( toY );
					int fromMonth = ( fromS - 1 ) * 6 + 1;
					int toMonth = ( toS - 1 ) * 6 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYYS-CCYYS
				// A period of time specified by giving the start semester
				// of a year followed by the end semester of a year (both
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 704:	
				{
					CheckLength(sValue, sFormat, 10 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromC, fromY );
					toY = Y2KConvert.Year( toC, toY );
					int fromMonth = ( fromS - 1 ) * 6 + 1;
					int toMonth = ( toS - 1 ) * 6 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// YYPYYP
				// Format of period to be given without hyphen (P = period of 4 months).
				case 705:	
				{
					CheckLength(sValue, sFormat, 6 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromP	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toP		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromY );
					toY = Y2KConvert.Year( toY );
					int fromMonth = ( fromP - 1 ) * 4 + 1;
					int toMonth = ( toP - 1 ) * 4 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYYP-CCYYP
				// Format of period to be given without hyphen (P = period of 4 months).
				case 706:	
				{
					CheckLength(sValue, sFormat, 10 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromP	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toP		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromC, fromY );
					toY = Y2KConvert.Year( toC, toY );
					int fromMonth = ( fromP - 1 ) * 4 + 1;
					int toMonth = ( toP - 1 ) * 4 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// YYQ-YYQ
				// A period of time specified by giving the start quarter
				// of a year followed by the end quarter of year (both not
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 707:
				{
					CheckLength(sValue, sFormat, 6 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromQ	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toQ		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromY );
					toY = Y2KConvert.Year( toY );
					int fromMonth = ( fromQ - 1 ) * 3 + 1;
					int toMonth = ( toQ - 1 ) * 3 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYYQ-CCYYQ
				// A period of time specified by giving the start quarter
				// of a year followed by the end quarter of year (both
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 708:	
				{
					CheckLength(sValue, sFormat, 10 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromQ	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toQ		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					fromY = Y2KConvert.Year( fromC, fromY );
					toY = Y2KConvert.Year( toC, toY );
					int fromMonth = ( fromQ - 1 ) * 3 + 1;
					int toMonth = ( toQ - 1 ) * 3 + 1;

					result = new Altova.Types.Duration( toY - fromY, toMonth - fromMonth, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// YYMM-YYMM
				// A period of time specified by giving the start month of
				// a year followed by the end month of a year (both not
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 709:
				{
					CheckLength(sValue, sFormat, 8 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					fromY = Y2KConvert.Year( fromY );
					toY = Y2KConvert.Year( toY );

					result = new Altova.Types.Duration( toY - fromY, toM - fromM, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYYMM-CCYYMM
				// A period of time specified by giving the start month of
				// a year followed by the end month of a year (both
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 710:
				{
					CheckLength(sValue, sFormat, 12 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					fromY = Y2KConvert.Year( fromC, fromY );
					toY = Y2KConvert.Year( toC, toY );

					result = new Altova.Types.Duration( toY - fromY, toM - fromM, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// CCYYMMDD-CCYYMMDD
				// Format of period to be given in actual message without
				// hyphen.
				// Note: 
				// 1. This code value will be removed effective with
				// directory D.03B.
				case 711:
				{
					CheckLength(sValue, sFormat, 16 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// YYMMDDHHMM-YYMMDDHHMM
				// A period of time specified by giving the start time
				// followed by the end time (format year, month, day, hour
				// and minute). Data is to be transmitted as consecutive
				// characters without hyphen.
				case 713:
				{
					CheckLength(sValue, sFormat, 20 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), fromM, fromD, fromTH, fromTM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), toM, toD, toTH, toTM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// YYWW-YYWW
				// A period of time specified by giving the start week of a
				// year followed by the end week of year (both not
				// including century). Data is to be transmitted as
				// consecutive characters without hyphen.
				case 715:
				{
					CheckLength(sValue, sFormat, 8 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromW	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toW		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), 1, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), 1, 1, 0, 0, 0 );
					from		= Lang.DatetimeAdd( from, new Altova.Types.Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
					to			= Lang.DatetimeAdd( to, new Altova.Types.Duration(0, 0, 7 * toW, 0, 0, 0, 0.0, false) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// CCYYWW-CCYYWW
				// A period of time specified by giving the start week of a
				// year followed by the end week of year (both including
				// century). Data is to be transmitted as consecutive
				// characters without hyphen.
				case 716:
				{
					CheckLength(sValue, sFormat, 12 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromW	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toW		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), 1, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), 1, 1, 0, 0, 0 );
					from		= Lang.DatetimeAdd( from, new Altova.Types.Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
					to			= Lang.DatetimeAdd( to, new Altova.Types.Duration(0, 0, 7 * toW, 0, 0, 0, 0.0, false) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// YYMMDD-YYMMDD
				// A period of time specified by giving the start date
				// followed by the end date (both not including century).
				// Data is to be transmitted as consecutive characters
				// without hyphen.
				case 717:
				{
					CheckLength(sValue, sFormat, 12 );
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// CCYYMMDD-CCYYMMDD
				// A period of time specified by giving the start date
				// followed by the end date (both including century). Data
				// is to be transmitted as consecutive characters without
				// hyphen.
				case 718:
				{
					CheckLength(sValue, sFormat, 16 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// CCYYMMDDHHMM-CCYYMMDDHHMM
				// A period of time which includes the century, year,
				// month, day, hour and minute. Format of period to be
				// given in actual message without hyphen.
				case 719:
				{
					CheckLength(sValue, sFormat, 24 );
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, fromTH, fromTM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, toTH, toTM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

				// DHHMM-DHHMM
				// Format of period to be given without hyphen (D=day of
				// the week, 1=Monday; 2=Tuesday; ... 7=Sunday).
				case 720:
				{
					CheckLength(sValue, sFormat, 10 );
					int fromDOW	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toDOW	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					
					fromDOW = ( fromDOW % 7 ) + 1;
					toDOW	= ( toDOW % 7 ) + 1;

					Altova.Types.DateTime from = new Altova.Types.DateTime(1, 1, 1, fromTH, fromTM, 0.0 );
					Altova.Types.Duration oneday = new Altova.Types.Duration( 0, 0, 1, 0, 0, 0, 0.0, false );
					while( Lang.Weekday( from ) != fromDOW )
						from = Lang.DatetimeAdd( from, oneday );
					
					Altova.Types.DateTime to = new Altova.Types.DateTime( from.Value.Year, from.Value.Month, from.Value.Day, toTH, toTM, 0 );
					while( Lang.Weekday( to ) != toDOW )
						to = Lang.DatetimeAdd( to, oneday );
					
					result = Lang.DatetimeDiff( to, from );
				}
					break;

				// Year
				// To indicate a quantity of years.
				case 801:
				{
					year = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( year, 0, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// Month
				// To indicate a quantity of months.
				case 802:
				{
					month = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, month, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// Week
				// To indicate a quantity of weeks.
				case 803:
				{
					week = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, week * 7, 0, 0, 0, 0.0, false );
				}
					break;

				// Day
				// To indicate a quantity of days.
				case 804:
				{
					day = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, day, 0, 0, 0, 0.0, false );
				}
					break;

				// Hour
				// To indicate a quantity of hours.
				case 805:
				{
					hour = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, hour, 0, 0, 0.0, false );
				}
					break;

				// Minute
				// To indicate a quantity of minutes.
				case 806:
				{
					minute = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, 0, minute, 0, 0.0, false );
				}
					break;

				// Second
				// To indicate a quantity of seconds.
				case 807:
				{
					seconds = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, 0, 0, seconds, 0.0, false );
				}
					break;

				// Semester
				// To indicate a quantity of semesters (six months).
				case 808:
				{
					int semester = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, semester * 6, 0, 0, 0, 0, 0.0, false );
				}
					break;

				// Four months period
				// To indicate a quantity of four months periods.
				case 809:
				{
					int fourMonth = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, fourMonth * 4, 0, 0, 0, 0, 0.0, false );
				}
					break;
		
				// Trimester
				// To indicate a quantity of trimesters (three months).
				case 810:
				{
					int trimester = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, trimester * 3, 0, 0, 0, 0, 0.0, false );
				}
					break;
		
				// Half month
				// To indicate a quantity of half months.
				case 811:
				{
					int halfMonth = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, halfMonth / 2, (halfMonth % 2) * 15, 0, 0, 0, 0.0, false );
				}
					break;
		
				// Ten days
				// To indicate a quantity of ten days periods.
				case 812:
				{
					int tenDays = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, tenDays * 10, 0, 0, 0, 0.0, false );
				}
					break;
		
				default:
				{
					if ( bRaiseExc ) throw new ConversionException("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'");
				}
					break;
			}

			return result;
		}

		//The result is the date/datetime/time/duration value extracted from the coded source using the given format code.
		public static string Autoformat(string sValue, string sFormat)
		{
			string result = null;

			int i = 0;
			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// DDD
				// Day's number within a specific year: D = Day.
				case 107:
				{
					CheckLength(sValue, sFormat, 3);
					// Note: gDay cannot accommodate all values. So we return a days-duration.
					int days = Convert.ToInt32( sValue );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, days, 0, 0, 0, 0.0, false );
					result = dur.ToString();
				}
					break;

				// WW
				// Week's number within a specific year: W = Week.
				case 108:	
				{
					CheckLength(sValue, sFormat, 2);
					// Note: A 'gWeek' does not exist and gDay cannot accommodate all values. So we return a days-duration.
					int weeksNum = Convert.ToInt32( sValue );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, weeksNum * 7, 0, 0, 0, 0.0, false );
					result = dur.ToString();
				}
					break;

				// MM
				// Month's number within a specific year: M = Month.
				case 109:
				{
					CheckLength(sValue, sFormat, 2);
					// gMonth
					int month = Convert.ToInt32( sValue );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, month, 0, 0, 0, 0, 0.0, false );
					result = dur.ToString();
				}
					break;

				// DD
				// Day's number within is a specific month: D = Day.
				case 110:
				{		
					CheckLength(sValue, sFormat, 2);
					// gDay
					int days = Convert.ToInt32( sValue );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, days, 0, 0, 0, 0.0, false );
					result = dur.ToString();
				}
					break;

				// CC
				// Century.
				case 600:
				{
					CheckLength(sValue, sFormat, 2);
					int century = Convert.ToInt32( sValue );
					int number = Y2KConvert.Year( century, 0 );
					result = number.ToString("0000");
				}
					break;

				// YY
				// Calendar year: Y = Year.
				case 601:
				{
					CheckLength(sValue, sFormat, 2);
					// gYear
					int number = Y2KConvert.Year( Convert.ToInt32( sValue ) );
					result = number.ToString("0000");
				}
					break;

				// CCYY
				// Calendar year including century: C = Century; Y = Year.
				case 602:
				{
					CheckLength(sValue, sFormat, 4);
					// gYear
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int number = Y2KConvert.Year( cc, yy );
					result = number.ToString("0000");
				}
					break;

				// YYS
				// Semester in a calendar year: Y = Year; S = Semester.
				case 603:	
				{
					CheckLength(sValue, sFormat, 3);
					// gYearMonth
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int semester = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;	
					result = Y2KConvert.Year( yy ).ToString("0000") + "-" + ((semester - 1) * 6 + 1).ToString("00");
				}
					break;

				// CCYYS
				// Semester in a calendar year: C = Century; Y = Year; S = Semester.
				case 604:
				{
					CheckLength(sValue, sFormat, 5);
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int semester = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;					
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + ((semester - 1) * 6 + 1).ToString("00");
				}
					break;

				// CCYYQ
				// Quarter in a calendar year: C = Century; Y = Year; Q = Quarter.
				case 608:	
				{
					CheckLength(sValue, sFormat, 5);
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int quarter = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					if ( quarter != 1)
						quarter = ( ( quarter - 1 ) * 3 + 1);		
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + ( quarter ).ToString("00");
				}
					break;

				// YYMM
				// Month within a calendar year: Y = Year; M = Month.
				case 609:
				{
					CheckLength(sValue, sFormat, 4);
					// gYearMonth
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result = Y2KConvert.Year( yy ).ToString("0000") + "-" + mm.ToString("00");
				}
					break;

				// CCYYMM
				// Month within a calendar year: CC = Century; Y = Year; M = Month.
				case 610:
				{
					CheckLength(sValue, sFormat, 6);
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + mm.ToString("00");
				}
					break;

				// YYMMA
				// To specifiy a ten-day period within a month of a year (A = ten day period).
				case 613:
				{
					CheckLength(sValue, sFormat, 5);
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int period = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;

					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( yy ), mm, 10 * (period - 1) + 1 );
					result = date.ToString(Altova.Types.DateTimeFormat.W3_date);
				}
					break;

				// CCYYMMA
				// To specifiy a ten-day period within a month of a year, including century (A = ten day period).
				case 614:
				{
					CheckLength(sValue, sFormat, 7);
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int period = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( cc, yy ), mm, 10 * (period - 1) + 1 );
					result = date.ToString(Altova.Types.DateTimeFormat.W3_date);
				}
					break;

				// Day of the week
				// Numeric representation of the day (Monday = 1).
				case 813:
				{
					int dayofweek = Convert.ToInt32( sValue );
					dayofweek = (dayofweek + 6) % 7;	// make Monday = 0
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, dayofweek, 0, 0, 0, 0.0, false );
					result = dur.ToString();
				}
					break;

				// Working days
				// Number of working days.
				case 814:
				{
					int number = Convert.ToInt32( sValue );
					number = (number / 5) * 7 + number % 5;
					if( number >= 0 )
						result = "P" + number.ToString() + "D";
					else
						result = "-P" + (-number).ToString() + "D";
				}
					break;

				default:
				{
					Altova.Types.DateTime time = Edifact.ToTime(sValue, sFormat, false);
					if (time != null) return time.ToString(Altova.Types.DateTimeFormat.W3_time);

					Altova.Types.DateTime date = Edifact.ToDate(sValue, sFormat, false);
					if (date != null) return date.ToString(Altova.Types.DateTimeFormat.W3_date);

					Altova.Types.DateTime datetime = Edifact.ToDatetime(sValue, sFormat, false);
					if (datetime != null) return datetime.ToString();

					Altova.Types.Duration duration = Edifact.ToDuration(sValue, sFormat, false);
					if (duration != null) return duration.ToString();

					result = sValue;
				}
					break;
			}

			return result;
		}

		private static void CheckMinMaxLength(string sValue, string sFormat, int nMinLength, int nMaxLength)
		{
			if ( ( sValue.Length < nMinLength ) || ( sValue.Length > nMaxLength ) )
				throw new ConversionException ("Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'. Expected length between '" + nMinLength + "' and '" + nMaxLength + "'." );
		}

		private static void CheckLength( string sValue, string sFormat, int nLength )
		{
			if ( sValue.Length != nLength)
				throw new ConversionException ("Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'. Expected length '" + nLength + "'." );
		}

		#endregion // datetime functions


		#region helpers
			
		class Y2KConvert
		{
			public static int Year( int nYear )
			{
				return nYear > 50 ? 1900 + nYear : 2000 + nYear;
			}

			public static int Year( int nCentury, int nYear )
			{
				return (nCentury * 100) + nYear;
			}

		}

		class TZConvert
		{

			struct TimeZoneData
			{
				public string	sName;
				public float	dOffset;

				public TimeZoneData( string name, float offset )
				{
					sName = name;
					dOffset = offset;
				}			
			}

			static readonly TimeZoneData[] arrAbb = 
			{
				new TimeZoneData("NST",+12.0f),	/* Pacific/Auckland */
				new TimeZoneData("SST",+11.0f),	/* Pacific/Guadalcanal */
				new TimeZoneData("AET",+10.0f),	/* Australia/Sydney */
				new TimeZoneData("ACT", +9.5f),	/* Australia/Darwin */
				new TimeZoneData("JST", +9.0f),	/* Asia/Tokyo */
				new TimeZoneData("CTT", +8.0f),	/* Asia/Shanghai */
				new TimeZoneData("VST", +7.0f),	/* Asia/Saigon */
				new TimeZoneData("BST", +6.0f),	/* Asia/Dacca */
				new TimeZoneData("IST", +5.5f),	/* Asia/Calcutta */
				new TimeZoneData("PLT", +5.0f),	/* Asia/Karachi */
				new TimeZoneData("NET", +4.0f),	/* Asia/Yerevan */
				new TimeZoneData("MET", +3.5f),	/* Asia/Tehran */
				new TimeZoneData("EAT", +3.0f),	/* Africa/Addis_Ababa */
				new TimeZoneData("EET", +2.0f),	/* Europe/Istanbul */
				new TimeZoneData("ART", +2.0f),	/* Africa/Cairo */
				new TimeZoneData("CAT", +2.0f),	/* Africa/Harare */
				new TimeZoneData("ECT", +1.0f),	/* Europe/Paris */
				new TimeZoneData("CET", +1.0f),	/* Europe/Paris */
				new TimeZoneData("GMT",  0.0f),	/* GMT */
				new TimeZoneData("UT",   0.0f),	/* GMT */
				new TimeZoneData("UTC",  0.0f),	/* GMT */
				new TimeZoneData("BET", -3.0f),	/* America/Sao_Paulo */
				new TimeZoneData("AGT", -3.0f),	/* America/Buenos_Aires */
				new TimeZoneData("CNT", -3.5f),	/* America/St_Johns */
				new TimeZoneData("PRT", -5.0f),	/* America/Puerto_Rico */
				new TimeZoneData("EST", -5.0f),	/* America/New_York */
				new TimeZoneData("IET", -5.0f),	/* America/Indianapolis */
				new TimeZoneData("CST", -6.0f),	/* America/Chicago */
				new TimeZoneData("MST", -7.0f),	/* America/Denver */
				new TimeZoneData("PNT", -7.0f),	/* America/Phoenix */
				new TimeZoneData("PST", -8.0f),	/* America/Los_Angeles */
				new TimeZoneData("MDT", -8.0f),	/* America/Boise */			/* Mountain Standard Time */
				new TimeZoneData("AST", -9.0f),	/* America/Anchorage */
				new TimeZoneData("PDT", -9.0f),	/* America/Dawson */		/* Pacific Standard Time */
				new TimeZoneData("HST",-10.0f),	/* Pacific/Honolulu */
				new TimeZoneData("TKT",-10.0f),	/* Pacific/Fakaofo */		/* Tokelau Time */
				new TimeZoneData("CKT",-10.0f),	/* Pacific/Rarotonga */		/* Cook Is. Time */
				new TimeZoneData("MIT",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("WST",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("SST",-11.0f),	/* Pacific/Midway */		/* Samoa Standard Time */
				new TimeZoneData("NUT",-11.0f),	/* Pacific/Niue */			/* Niue Time */
			};

			static readonly TimeZoneData[] arrMil = 
			{
				new TimeZoneData("Z", 0.0f), // Zulu Time ( UTC )
				new TimeZoneData("A", +1.0f), new TimeZoneData("B", +2.0f), new TimeZoneData("C", +3.0f), new TimeZoneData("D", +4.0f), new TimeZoneData("E", +5.0f), new TimeZoneData("F", +6.0f), new TimeZoneData("G", +7.0f), new TimeZoneData("H", +8.0f), new TimeZoneData("I", +9.0f), new TimeZoneData("K", +10.0f), new TimeZoneData("L", +11.0f), new TimeZoneData("M", +12.0f),
				new TimeZoneData("N", -1.0f), new TimeZoneData("O", -2.0f), new TimeZoneData("P", -3.0f), new TimeZoneData("Q", -4.0f), new TimeZoneData("R", -5.0f), new TimeZoneData("S", -6.0f), new TimeZoneData("T", -7.0f), new TimeZoneData("U", -8.0f), new TimeZoneData("V", -9.0f), new TimeZoneData("W", -10.0f), new TimeZoneData("X", -11.0f), new TimeZoneData("Y", -12.0f), 
			};

			public static int Timezone( string sTimezone )
			{
				// Input Parameter:
				// coded tz value like "GMT", "Z" or "+10"
				// Return Value:
				// the corresponding timezone offset in MINUTES!
				// when the tz couldn't be found the return value is 0.
				// Possible formats for Timezone resolution:
				// - Hour offset from GMT (+/-HH)
				// - Three letter timezone code
				// - One letter millitary code (Z=UTC)


				// Pass 1: 
				// check the length of the input string.
				// For single letter lookup the timezone offset from the tzMil array.
				if( sTimezone.Length == 1 )
				{
					foreach( TimeZoneData data in arrMil )
						if( sTimezone == data.sName ) 
							return (int)( 60 * data.dOffset );
				}
				else		
				{
					// Pass 2: 
					// lookup the timezone offset from tzAbb array
					// all standard timezones and the offsets are recorded
					foreach( TimeZoneData data in arrAbb )
						if( sTimezone == data.sName ) 
							return (int)( 60 * data.dOffset );

					// Pass 3: 
					// try to extract the +/-HH format
					int nHours = Convert.ToInt32( sTimezone );
					return 60 * nHours;
				}
				return 0;
			}	
		}

		#endregion // helpers

	}
}
