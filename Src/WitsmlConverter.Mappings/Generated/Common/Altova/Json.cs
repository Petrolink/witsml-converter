//
// Json.cs
//
// This file was generated by MapForce 2023sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//


using System;
using System.Collections.Generic;

namespace Altova.Json
{
	public enum Type
	{
		Null,
		String,
		Number,
		Boolean,
		Array,
		Object
	}

	public class Validator
	{
		internal Dictionary<string, ValueAcceptor> _schemamap = new Dictionary<string, ValueAcceptor>();

		internal Validator(ValueAcceptor[] acceptors)
		{
			foreach (ValueAcceptor acceptor in acceptors)
			{
				_schemamap.Add(acceptor.Id, acceptor);
			}
		}
	}


	public abstract class Value : Altova.Mapforce.IMFNode
	{
		public bool IsA(string schema)
		{
			return _info != null ? _info.IsA(schema) : false;
		}

		public abstract Type Type { get; }

		public string LocalName
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NamespaceURI
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Mapforce.MFNodeKind NodeKind
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NodeName
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string Prefix
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public virtual object TypedValue
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Types.QName GetQNameValue()
		{
			throw new InvalidOperationException();
		}

		public System.Collections.IEnumerable Select(Altova.Mapforce.MFQueryKind kind, object query)
		{
			if (Type == Type.Null)
				return new Value[0];
			else
				throw new InvalidOperationException();
		}

		ValidationInfo _info;

		public void AssignAdditionalSchema(string token)
        {
			if (_info == null)
				_info = new ValidationInfo(token);
			else
				_info.AddSchema(token);
        }

		protected abstract ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, Dictionary<Value, ValidationInfo> itemInfos);

		protected static void Merge(Dictionary<Value, ValidationInfo> itemInfos, Value value, ValidationInfo info)
		{
			ValidationInfo vi;
			if (itemInfos.TryGetValue(value, out vi))
			{
				vi.Merge(info);
			}
			else
				itemInfos.Add(value, info);
		}

		protected static void Merge(Dictionary<Value, ValidationInfo> itemInfos, Dictionary<Value, ValidationInfo> local)
		{
			foreach (var item in local)
			{
				ValidationInfo e;
				if (itemInfos.TryGetValue(item.Key, out e))
				{
					e.Merge(item.Value);
				}
				else
					itemInfos.Add(item.Key, item.Value);
			}
		}

		protected internal ValidationInfo DoValidate(Validator validator, ValueAcceptor schema, Dictionary<Value, ValidationInfo> itemInfos)
		{
			Dictionary<Value, ValidationInfo> local = new Dictionary<Value, ValidationInfo>();
			ValidationInfo res = DoValidateCore(validator, schema, local);
			if (!res.IsValid)
				return res;
			foreach (var also in schema.Also)
			{
				ValidationInfo combined = null;
				int matches = 0;
				foreach (var acceptor in also.Acceptors)
				{
					var r = DoValidate(validator, acceptor, local);
					if (r.IsValid)
					{
						if (combined != null) combined.Merge(r); else combined = r;
						matches += 1;
					}
				}
				if (also.MinAccepting.HasValue && matches < also.MinAccepting.Value)
					return new ValidationInfo(Validity.Invalid);
				if (also.MaxAccepting.HasValue && matches > also.MaxAccepting.Value)
					return new ValidationInfo(Validity.Invalid);
				if (combined != null)
					res.Merge(combined);
			}
			Merge(itemInfos, local);
			return res;
		}

		protected internal ValidationInfo DoValidate(Validator validator, Reference reference, Dictionary<Value, ValidationInfo> itemInfos)
		{
			ValueAcceptor acceptor;
			if (validator._schemamap.TryGetValue(reference.Target, out acceptor))
				return DoValidate(validator, acceptor, itemInfos);
			return new ValidationInfo(Validity.Invalid);
		}

		public void Validate(ValueAcceptor[] schemas, bool jsonLines)
		{
			Validator validator = new Validator(schemas);
			Dictionary<Value, ValidationInfo> itemInfos = new Dictionary<Value, ValidationInfo>();
			if (jsonLines)
			{
				var array = this as Array;
				if (!object.ReferenceEquals(array, null))
					foreach (var item in array.Items)
						item.Validate(schemas, false);
			}
			else
			{
				var r = DoValidate(validator, schemas[0], itemInfos);
				Merge(itemInfos, this, r);
				Apply(itemInfos);
			}
		}

		protected abstract void ApplyDescendants(Dictionary<Value, ValidationInfo> itemInfos);

		protected internal void Apply(Dictionary<Value, ValidationInfo> itemInfos)
		{
			itemInfos.TryGetValue(this, out _info);
			ApplyDescendants(itemInfos);
		}

		protected new abstract int GetHashCode();
		protected new abstract bool Equals(object obj);

		public class ValueEqualityComparer : System.Collections.Generic.IEqualityComparer<Value>
		{
			public bool Equals(Value x, Value y) { return x.Equals(y); }
			public int GetHashCode(Value obj) { return obj.GetHashCode(); }
		}
	}

	public class Primitive : Value
	{
		private readonly Type type;
		private object value;

		public Primitive(string s) { type = Type.String; value = s; }
		public Primitive(decimal d) { type = Type.Number; value = d; }
		public Primitive(bool b) { type = Type.Boolean; value = b; }
		public Primitive(Type type, string value) { this.type = type; this.value = value; }

		private Primitive() { type = Type.Null; }

		public override Type Type { get { return type; } }
		public object Value { get { return value; } }

		public static readonly Primitive Null = new Primitive();

		string ValueAsString()
		{
			string s = value as string;
			if (!object.ReferenceEquals(s, null))
				return s;
			switch (type)
			{
				case Type.Number:
					return ((decimal)value).ToString(System.Globalization.CultureInfo.InvariantCulture);
				case Type.Null:
					return "null";
				case Type.Boolean:
					return ((bool)value) ? "true" : "false";
				default:
					throw new InvalidOperationException("JSON primitive is invalid.");
			}

		}

		protected override int GetHashCode()
		{
			string s = ValueAsString();
			switch (type)
			{
				case Type.String:
					return s.GetHashCode();
				case Type.Boolean:
					return s == "true" ? 2 : 1;
				case Type.Null:
					return 0;
			}
			return 961757429;
		}

		protected override bool Equals(object obj)
		{
			var p = obj as Primitive;
			if (object.ReferenceEquals(p, null))
				return false;
			if (type != p.type)
				return false;
			switch (type)
			{
				case Type.String:
				case Type.Boolean:
					return ValueAsString() == p.ValueAsString();
				case Type.Null:
					return true;
				case Type.Number:
					return CompareNumbers(ValueAsString(), p.ValueAsString()) == 0;
				default:
					return false;
			}
		}

		protected override void ApplyDescendants(Dictionary<Value, ValidationInfo> itemInfos) { }

		ValidationInfo ValidateBoolean(string id, BooleanAcceptor schema)
		{
			if (!Object.ReferenceEquals(schema, null))
			{
				string s = value as string;
				if (s != null)
				{
					if (schema.AllowTrue && s == "true")
						return new ValidationInfo(id);
					if (schema.AllowFalse && s == "false")
						return new ValidationInfo(id);
				}
				else
				{
					if (schema.AllowTrue && (bool)value)
						return new ValidationInfo(id);
					if (schema.AllowFalse && !(bool)value)
						return new ValidationInfo(id);
				}
			}
			return new ValidationInfo(Validity.Invalid);
		}

		ValidationInfo ValidateNull(string id, NullAcceptor schema)
		{
			if (!Object.ReferenceEquals(schema, null))
			{
				return new ValidationInfo(id);
			}
			return new ValidationInfo(Validity.Invalid);
		}

		internal struct CanonicalNumber
		{
			public string Mantissa;
			public bool Negative;
			public int Exponent;
			public bool Transfinite;
		}

		static internal void ComputeCanonical(string num, out CanonicalNumber res)
		{
			res = new CanonicalNumber();
			res.Transfinite = false;

			// To support extended JSON stuff (not covered by core JSON grammar):
			if (num == "Infinity")
			{
				res.Transfinite = true;
				res.Exponent = 0;
				res.Negative = false;
				res.Mantissa = "Infinity";
				return;
			}
			else if (num == "-Infinity")
			{
				res.Transfinite = true;
				res.Exponent = 0;
				res.Negative = true;
				res.Mantissa = "Infinity";
				return;
			}
			else if (num == "NaN" || num == "-NaN" || num == "+NaN")
			{
				res.Transfinite = true;
				res.Exponent = 1;
				res.Negative = false;
				res.Mantissa = "NaN";
				return;
			}
			if (num.StartsWith("0x") || num.StartsWith("0X"))
			{
				var value = long.Parse(num.Substring(2), System.Globalization.NumberStyles.HexNumber);
				num = value.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
			}

			int i = 0;
			if (i != num.Length && num[i] == '-')
			{
				res.Negative = true;
				++i;
			}
			else
			{
				res.Negative = false;
			}
			if (i == num.Length)
				throw new ArgumentException("Not a valid number", num);

			res.Exponent = 0;

			int ld;

			if (num[i] == '0')
			{
				if (i + 1 == num.Length || num[i + 1] == 'e' || num[i + 1] == 'E')
				{
					res.Negative = false;
					res.Mantissa = "";
					res.Exponent = int.MinValue;
					return;
				}
				if (num[i + 1] != '.' || i + 2 == num.Length)
					throw new ArgumentException("Not a valid number", num);

				i += 2;
				res.Exponent -= 1;
				while (num[i] == '0')
				{
					if (++i == num.Length || num[i] == 'e' || num[i] == 'E')
					{
						res.Negative = false;
						res.Mantissa = "";
						res.Exponent = int.MinValue;
						return;
					}
					res.Exponent -= 1;
				}
				ld = i + 1;
			}
			else
			{
				ld = i + 1;
				while (ld != num.Length && num[ld] != '.' && num[ld] != 'e' && num[ld] != 'E')
				{
					++ld;
					res.Exponent += 1;
				}
				if (ld != num.Length && num[ld] == '.')
					++ld;

			}
			while (ld != num.Length && num[ld] != 'e' && num[ld] != 'E')
				++ld;

			var exp = ld;
			while (ld > i)
			{
				if (num[ld - 1] == '0' || num[ld - 1] == '.')
					--ld;
				else
					break;
			}

			int x = num.IndexOf('.', i, ld - i);
			if (x >= 0)
				res.Mantissa = num.Substring(i, x - i) + num.Substring(x + 1, ld - x - 1);
			else
				res.Mantissa = num.Substring(i, ld - i);

			if (exp != num.Length)
			{
				bool esign = false;
				int eval = 0;
				exp += 1;
				if (exp == num.Length)
					throw new ArgumentException("Not a valid number", num);
				if (num[exp] == '+')
					++exp;
				else if (num[exp] == '-')
				{
					esign = true;
					++exp;
				}
				if (exp == num.Length)
					throw new ArgumentException("Not a valid number", num);

				while (exp != num.Length)
				{
					eval = eval * 10 + (num[exp] - '0');
					++exp;
				}
				if (esign) res.Exponent -= eval;
				else res.Exponent += eval;
			}

		}

		static int CompareNumbers(string a, string b)
		{
			CanonicalNumber ca, cb;
			ComputeCanonical(a, out ca);
			ComputeCanonical(b, out cb);

			// Sort NaN first.
			if (ca.Transfinite && ca.Exponent != 0)
			{
				if (cb.Transfinite && cb.Exponent != 0)
					return 0;
				else
					return -1;
			}
			if (cb.Transfinite && cb.Exponent != 0)
				return +1;

			if (ca.Negative == cb.Negative)
			{
				if (ca.Transfinite && cb.Transfinite)
					return 0;
				if (ca.Transfinite)
					return +1;
				if (cb.Transfinite)
					return -1;

				// same sign
				if (ca.Exponent == cb.Exponent)
				{
					// same order of magnitude
					return string.CompareOrdinal(ca.Mantissa, cb.Mantissa) * (ca.Negative ? -1 : +1);
				}
				else
				{
					return (ca.Exponent < cb.Exponent ? -1 : +1) * (ca.Negative ? -1 : +1);
				}
			}
			else
			{
				return ca.Negative ? -1 : +1;
			}
		}

		static int ModExp(long value, int exponent, int modulus)
		{
			long result = 1;
			value %= modulus;
			while (exponent > 0)
			{
				if ((exponent & 1) == 1)
					result = (result * value) % modulus;
				exponent >>= 1;
				value = (value * value) % modulus;
			}
			return (int)result;
		}

		static bool IsMultipleOf(string numerator, string denominator)
		{
			CanonicalNumber canonicalNumerator;
			CanonicalNumber canonicalDenominator;
			ComputeCanonical(numerator, out canonicalNumerator);
			ComputeCanonical(denominator, out canonicalDenominator);
			if (canonicalNumerator.Exponent == int.MinValue)
				return true;
			if (canonicalDenominator.Exponent == int.MinValue)
				return false;

			int leastSignificantDenominator = canonicalDenominator.Exponent - canonicalDenominator.Mantissa.Length + 1;
			int lastDigitPosition = canonicalNumerator.Exponent - leastSignificantDenominator - canonicalNumerator.Mantissa.Length + 1;
			if (lastDigitPosition < 0)
				return false;

			var basis = int.Parse(canonicalDenominator.Mantissa);
			if (basis == 1)
				return true;

			long weight = ModExp(10, lastDigitPosition, basis);
			long residue = 0;
			for (int i = 0; i != canonicalNumerator.Mantissa.Length; ++i)
			{
				if (weight == 0)
					break;
				int digit = canonicalNumerator.Mantissa[canonicalNumerator.Mantissa.Length - i - 1] - '0';
				residue = (residue + digit * weight) % basis;
				weight = (weight * 10) % basis;
			}

			return residue == 0;
		}

		ValidationInfo ValidateNumber(string id, NumberAcceptor schema)
		{
			if (!Object.ReferenceEquals(schema, null))
			{
				if (!(value is string))
					value = ((decimal)value).ToString(System.Globalization.NumberFormatInfo.InvariantInfo);

				if (schema.Maximum.HasValue)
				{
					var n = CompareNumbers((string)value, schema.Maximum.Value.Value);
					if (n > 0 || (n == 0 && schema.Maximum.Value.Exclusive))
						return new ValidationInfo(Validity.Invalid);
				}
				if (schema.Minimum.HasValue)
				{
					var n = CompareNumbers((string)value, schema.Minimum.Value.Value);
					if (n < 0 || (n == 0 && schema.Minimum.Value.Exclusive))
						return new ValidationInfo(Validity.Invalid);
				}
				if (!Object.ReferenceEquals(schema.MultipleOf, null))
				{
					if (!IsMultipleOf((string)value, schema.MultipleOf))
						return new ValidationInfo(Validity.Invalid);
				}
				if (!Object.ReferenceEquals(schema.Pattern, null))
				{
					if (!System.Text.RegularExpressions.Regex.IsMatch((string)value, schema.Pattern, System.Text.RegularExpressions.RegexOptions.ECMAScript))
						return new ValidationInfo(Validity.Invalid);
				}
				if (!Object.ReferenceEquals(schema.Enum, null))
				{
					bool found = false;
					foreach (var e in schema.Enum)
					{
						if (CompareNumbers((string)value, e) == 0)
						{
							found = true;
							break;
						}
					}
					if (!found)
						return new ValidationInfo(Validity.Invalid);
				}
				return new ValidationInfo(id);
			}
			return new ValidationInfo(Validity.Invalid);
		}

		static int JsonStringLength(string s)
		{
			int length = 0;
			foreach (char c in s)
			{
				if (char.IsHighSurrogate(c)) continue;
				length += 1;
			}
			return length;
		}

		ValidationInfo ValidateString(string id, StringAcceptor schema)
		{
			if (!Object.ReferenceEquals(schema, null))
			{
				if (schema.MinLength.HasValue)
				{
					if (JsonStringLength((string)value) < schema.MinLength.Value)
						return new ValidationInfo(Validity.Invalid);
				}
				if (schema.MaxLength.HasValue)
				{
					if (JsonStringLength((string)value) > schema.MaxLength.Value)
						return new ValidationInfo(Validity.Invalid);
				}
				if (!Object.ReferenceEquals(schema.Pattern, null))
				{
					if (!System.Text.RegularExpressions.Regex.IsMatch((string)value, schema.Pattern, System.Text.RegularExpressions.RegexOptions.ECMAScript))
						return new ValidationInfo(Validity.Invalid);
				}
				if (!Object.ReferenceEquals(schema.Enum, null))
				{
					bool found = false;
					foreach (var e in schema.Enum)
					{
						if ((string)value == e)
						{
							found = true;
							break;
						}
					}
					if (!found)
						return new ValidationInfo(Validity.Invalid);
				}
				return new ValidationInfo(id);
			}
			return new ValidationInfo(Validity.Invalid);
		}

		protected override ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, Dictionary<Value, ValidationInfo> itemInfos)
		{
			switch (type)
			{
				case Type.String: return ValidateString(schema.Id, schema.String);
				case Type.Number: return ValidateNumber(schema.Id, schema.Number);
				case Type.Boolean: return ValidateBoolean(schema.Id, schema.Boolean);
				case Type.Null: return ValidateNull(schema.Id, schema.Null);
				default: throw new InvalidOperationException("Value has invalid type.");
			}
		}

		public override object TypedValue
		{
			get
			{
				switch (type)
				{
					case Type.String:
						return value;
					case Type.Number:
						string s = value as string;
						if (s == null)
							return (decimal)value;
						else try
							{
								return decimal.Parse(s, System.Globalization.CultureInfo.InvariantCulture);
							}
							catch (FormatException)
							{
								return (decimal)double.Parse(s, System.Globalization.CultureInfo.InvariantCulture);
							}
					case Type.Boolean:
						string s2 = value as string;
						if (s2 == null)
							return (bool)value;
						else
							return s2 == "true";
					case Type.Null:
						return value;
					default:
						throw new InvalidOperationException("Value has invalid type.");
				}
			}
		}

	}
	public class Object : Value
	{
		private readonly Member[] members;
		public Object(Member[] members)
		{
			this.members = members;
		}

		public override Type Type { get { return Type.Object; } }

		public Member[] Members
		{
			get { return members; }
		}

		protected override void ApplyDescendants(Dictionary<Value, ValidationInfo> itemInfos)
		{
			foreach (Member m in members) { m.Value.Apply(itemInfos); }
		}

		protected override ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, Dictionary<Value, ValidationInfo> itemInfos)
		{
			if (!Object.ReferenceEquals(schema.Object, null))
			{
				int pc = Members.Length;
				if (schema.Object.MaxProperties.HasValue)
				{
					if (pc > schema.Object.MaxProperties.Value)
						return new ValidationInfo(Validity.Invalid);
				}
				if (schema.Object.MinProperties.HasValue)
				{
					if (pc < schema.Object.MinProperties.Value)
						return new ValidationInfo(Validity.Invalid);
				}

				bool[] propertiesRemoved = new bool[pc];

				var res = new ValidationInfo(schema.Id);

				foreach (var group in schema.Object.Groups)
				{
					bool[] removeAfterGroup = new bool[pc];

					foreach (var rule in group.Rules)
					{
						bool failedAny = false;
						bool matchedAny = false;
						var touched = new bool[pc];

						for (int n = 0; n != pc; ++n)
						{
							if (propertiesRemoved[n])
								continue;
							switch (rule.MatchKind)
							{
								case NameMatchKind.Exact:
									if (Members[n].Name != rule.NameMatch)
										continue;
									break;
								case NameMatchKind.Pattern:
									if (!System.Text.RegularExpressions.Regex.IsMatch(Members[n].Name, rule.NameMatch, System.Text.RegularExpressions.RegexOptions.ECMAScript))
										continue;
									break;
								case NameMatchKind.All:
									break;
							}
							matchedAny = true;
							touched[n] = true;
							var itemRes = Members[n].Value.DoValidate(validator, rule.ValueAcceptor, itemInfos);
							if (itemRes.Validity != Validity.Valid) failedAny = true;
							Merge(itemInfos, Members[n].Value, itemRes);
						}

						if (matchedAny)
						{
							if (!Object.ReferenceEquals(rule.PresentAcceptor, null))
							{
								var t = DoValidate(validator, rule.PresentAcceptor, itemInfos);
								if (t.Validity != Validity.Valid)
									failedAny = true;
								res.Merge(t);
							}
							switch (failedAny ? group.MatchFailure : group.MatchSuccess)
							{
								case PropertyGroupBehavior.Succeed:
									for (int i = 0; i != pc; ++i)
										removeAfterGroup[i] |= touched[i];
									break;
								case PropertyGroupBehavior.Fail:
									return new ValidationInfo(Validity.Invalid);
								case PropertyGroupBehavior.ContinueWithNext:
									break;
							}
						}
						else
						{
							if (!Object.ReferenceEquals(rule.AbsentAcceptor, null))
							{
								var t = DoValidate(validator, rule.AbsentAcceptor, itemInfos);
								if (t.Validity != Validity.Valid)
									return new ValidationInfo(Validity.Invalid);
								res.Merge(t);
							}
						}
					}

					for (int n = 0; n != pc; ++n)
						propertiesRemoved[n] |= removeAfterGroup[n];

					bool allPropertiesRemoved = true;
					foreach (bool b in propertiesRemoved)
						allPropertiesRemoved &= b;

					if (group.NonMatch == PropertyGroupBehavior.Succeed)
					{
						if (allPropertiesRemoved)
							break;
					}
					else if (group.NonMatch == PropertyGroupBehavior.Fail)
					{
						if (!allPropertiesRemoved)
							break;
						return new ValidationInfo(Validity.Invalid);
					}
				}

				return res;
			}

			return new ValidationInfo(Validity.Invalid);

		}

		protected override int GetHashCode()
		{
			List<Member> ma = new List<Member>(members);
			ma.Sort((x, y) => x.Name.CompareTo(y.Name));
			MakeUnique(ma);
			int n = 961761211;
			foreach (Member m in ma)
			{
				n ^= m.Name.GetHashCode() ^ m.Value.GetHashCode();
			}
			return n;
		}

		static void MakeUnique(List<Member> members)
		{
			int t = 0;
			for (int s = 1; s != members.Count; ++s)
			{
				if (members[s].Name == members[t].Name)
					members[t] = members[s]; // replace it, last one wins
				else
					members[++t] = members[s];
			}
			members.RemoveRange(t + 1, members.Count - t - 1);
		}

		protected override bool Equals(object obj)
		{
			var o = obj as Object;
			if (object.ReferenceEquals(o, null))
				return false;

			List<Member> ma = new List<Member>(members);
			List<Member> mb = new List<Member>(o.members);
			ma.Sort((x, y) => x.Name.CompareTo(y.Name));
			mb.Sort((x, y) => x.Name.CompareTo(y.Name));
			MakeUnique(ma);
			MakeUnique(mb);
			if (ma.Count != mb.Count)
				return false;
			for (int n = 0; n != ma.Count; ++n)
			{
				if (ma[n].Name != mb[n].Name)
					return false;
				if (!ma[n].Value.Equals(mb[n].Value))
					return false;
			}
			return true;
		}

	}
	public class Member : Altova.Mapforce.IMFNode
	{
		private readonly string name;
		private readonly Value value;

		public Member(string name, Value value)
		{
			this.name = name;
			this.value = value;
		}

		public Value Value { get { return value; } }
		public string Name { get { return name; } }

		public string LocalName
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NamespaceURI
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Mapforce.MFNodeKind NodeKind
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NodeName
		{
			get
			{
				return name;
			}
		}

		public string Prefix
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public object TypedValue
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Types.QName GetQNameValue()
		{
			throw new InvalidOperationException();
		}

		public System.Collections.IEnumerable Select(Altova.Mapforce.MFQueryKind kind, object query)
		{
			throw new InvalidOperationException();
		}
	}
	public class Array : Value
	{
		private readonly Value[] items;

		public override Type Type { get { return Type.Array; } }

		public Array(Value[] items)
		{
			this.items = items;
		}


		public Value[] Items { get { return items; } }

		protected override void ApplyDescendants(Dictionary<Value, ValidationInfo> itemInfos)
		{
			foreach (Value v in items) { v.Apply(itemInfos); }
		}


		protected override ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, Dictionary<Value, ValidationInfo> itemInfos)
		{
			if (!Object.ReferenceEquals(schema.Array, null))
			{
				if (schema.Array.MinItems.HasValue && schema.Array.MinItems > Items.Length)
					return new ValidationInfo(Validity.Invalid);
				if (schema.Array.MaxItems.HasValue && schema.Array.MaxItems < Items.Length)
					return new ValidationInfo(Validity.Invalid);

				if (!Object.ReferenceEquals(schema.Array.Items, null))
				{
					for (int i = 0; i != Items.Length; ++i)
					{
						var item = Items[i];
						var itemSchema = schema.Array.Items.Length > i ? schema.Array.Items[i] : schema.Array.Items[schema.Array.Items.Length - 1];
						var res = item.DoValidate(validator, itemSchema, itemInfos);
						if (res.Validity != Validity.Valid)
							return new ValidationInfo(Validity.Invalid);
						Merge( itemInfos, item, res );
					}
				}
				if (schema.Array.UniqueItems)
				{
					Dictionary<Value, object> hash = new Dictionary<Value, object>(new ValueEqualityComparer());
					foreach (var item in Items)
					{
						if (!hash.ContainsKey(item))
							hash.Add(item, null);
					}
					if (hash.Count != Items.Length)
						return new ValidationInfo(Validity.Invalid);
				}
				return new ValidationInfo(schema.Id);
			}
			return new ValidationInfo(Validity.Invalid);

		}

		protected override int GetHashCode()
		{
			int n = 979750913;
			foreach (Value v in Items)
			{
				n ^= v.GetHashCode();
			}
			return n;
		}

		protected override bool Equals(object obj)
		{
			var a = obj as Array;
			if (object.ReferenceEquals(a, null))
				return false;
			if (Items.Length != a.Items.Length)
				return false;
			for (int i = 0; i != items.Length; ++i)
				if (!Items[i].Equals(a.Items[i]))
					return false;
			return true;
		}

	}
	public class Document : Altova.Mapforce.IMFNode, Altova.Mapforce.IMFDocumentNode
	{
		private readonly Value value;
		private readonly string uri;
		public Value RootValue { get { return value; } }
		public string Uri { get { return uri; } }

		public Document(Value value, string uri)
		{
			this.value = value;
			this.uri = uri;
		}

		public string GetDocumentUri()
		{
			return uri;
		}

		public string LocalName
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NamespaceURI
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Mapforce.MFNodeKind NodeKind
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string NodeName
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public string Prefix
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public object TypedValue
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public Altova.Types.QName GetQNameValue()
		{
			throw new InvalidOperationException();
		}

		public System.Collections.IEnumerable Select(Altova.Mapforce.MFQueryKind kind, object query)
		{
			throw new InvalidOperationException();
		}
	}

	public sealed class Reference
	{
		private readonly string _reference;

		public string Target { get { return _reference; } }

		public Reference(string reference)
		{
			_reference = reference;
		}
	}

	public sealed class StringAcceptor
	{
		private readonly int? _minLength;
		private readonly int? _maxLength;
		private readonly string _pattern;
		private readonly string[] _enum;

		public int? MinLength { get { return _minLength; } }
		public int? MaxLength { get { return _maxLength; } }
		public string Pattern { get { return _pattern; } }
		public string[] Enum { get { return _enum; } }

		public StringAcceptor(int? minLength, int? maxLength, string pattern, string[] enum_)
		{
			_minLength = minLength;
			_maxLength = maxLength;
			_pattern = pattern;
			_enum = enum_;
		}
	}

	public struct Bound
	{
		public readonly string Value;
		public readonly bool Exclusive;
		public Bound(string value, bool exclusive) { Value = value; Exclusive = exclusive; }
	}

	public sealed class NumberAcceptor
	{
		private readonly Bound? _minimum;
		private readonly Bound? _maximum;
		private readonly string _multipleOf;
		private readonly string _pattern;
		private readonly string[] _enum;
		

		public Bound? Minimum { get { return _minimum; } }
		public Bound? Maximum { get { return _maximum; } }
		public string MultipleOf { get { return _multipleOf; } }
		public string Pattern { get { return _pattern; } }
		public string[] Enum { get { return _enum; } }

		public NumberAcceptor(Bound? minimum, Bound? maximum, string multipleOf, string pattern, string[] enum_)
		{
			_minimum = minimum;
			_maximum = maximum;
			_multipleOf = multipleOf;
			_pattern = pattern;
			_enum = enum_;
		}
	}

	public sealed class BooleanAcceptor
	{
		private readonly bool _allowFalse, _allowTrue;

		public bool AllowFalse { get { return _allowFalse; } }
		public bool AllowTrue { get { return _allowTrue; } }
		public BooleanAcceptor(bool allowFalse, bool allowTrue) { _allowFalse = allowFalse; _allowTrue = allowTrue; }
	}

	public sealed class NullAcceptor
	{

	}

	public sealed class ArrayAcceptor
	{
		private readonly int? _minItems;
		private readonly int? _maxItems;
		private readonly bool _uniqueItems;
		private readonly Reference[] _items;

		public int? MinItems { get { return _minItems; } }
		public int? MaxItems { get { return _maxItems; } }
		public bool UniqueItems { get { return _uniqueItems; } }
		public Reference[] Items { get { return _items; } }

		public ArrayAcceptor(int? minItems, int? maxItems, bool uniqueItems, Reference[] items)
		{
			_minItems = minItems;
			_maxItems = maxItems;
			_uniqueItems = uniqueItems;
			_items = items;
		}
	}

	public enum NameMatchKind { Exact, Pattern, All }

	public sealed class PropertyRule
	{
		private readonly string _nameMatch;
		private readonly NameMatchKind _matchKind;
		private readonly Reference _valueAcceptor;
		private readonly Reference _presentAcceptor;
		private readonly Reference _absentAcceptor;

		public string NameMatch { get { return _nameMatch; } }
		public NameMatchKind MatchKind { get { return _matchKind; } }
		public Reference ValueAcceptor { get { return _valueAcceptor; } }
		public Reference PresentAcceptor { get { return _presentAcceptor; } }
		public Reference AbsentAcceptor { get { return _absentAcceptor; } }

		public PropertyRule(string nameMatch, NameMatchKind matchKind, Reference valueAcceptor, Reference presentAcceptor, Reference absentAcceptor)
		{
			_nameMatch = nameMatch;
			_matchKind = matchKind;
			_valueAcceptor = valueAcceptor;
			_presentAcceptor = presentAcceptor;
			_absentAcceptor = absentAcceptor;
		}
	}

	public enum PropertyGroupBehavior { Succeed, Fail, ContinueWithNext }

	public sealed class PropertyGroup
	{
		private readonly PropertyGroupBehavior _matchSuccess;
		private readonly PropertyGroupBehavior _matchFailure;
		private readonly PropertyGroupBehavior _nonMatch;
		private readonly PropertyRule[] _rules;

		public PropertyGroupBehavior MatchSuccess { get { return _matchSuccess; } }
		public PropertyGroupBehavior MatchFailure { get { return _matchFailure; } }
		public PropertyGroupBehavior NonMatch { get { return _nonMatch; } }
		public PropertyRule[] Rules { get { return _rules; } }

		public PropertyGroup(PropertyGroupBehavior matchSuccess, PropertyGroupBehavior matchFailure, PropertyGroupBehavior nonMatch, PropertyRule[] rules)
		{
			_matchSuccess = matchSuccess;
			_matchFailure = matchFailure;
			_nonMatch = nonMatch;
			_rules = rules;
		}
	}

	public sealed class ObjectAcceptor
	{
		private readonly int? _minProperties;
		private readonly int? _maxProperties;
		private readonly PropertyGroup[] _groups;

		public int? MinProperties { get { return _minProperties; } }
		public int? MaxProperties { get { return _maxProperties; } }
		public PropertyGroup[] Groups { get { return _groups; } }

		public ObjectAcceptor(int? minProperties, int? maxProperties, PropertyGroup[] groups)
		{
			_minProperties = minProperties;
			_maxProperties = maxProperties;
			_groups = groups;
		}
	}

	public sealed class AlsoAcceptor
	{
		private readonly int? _minAccepting;
		private readonly int? _maxAccepting;
		private readonly Reference[] _acceptors;

		public int? MinAccepting { get { return _minAccepting; } }
		public int? MaxAccepting { get { return _maxAccepting; } }
		public Reference[] Acceptors { get { return _acceptors; } }

		public AlsoAcceptor(int? minAccepting, int? maxAccepting, Reference[] acceptors)
		{
			_minAccepting = minAccepting;
			_maxAccepting = maxAccepting;
			_acceptors = acceptors;
		}
	}

	public sealed class ValueAcceptor
	{
		private readonly string _id;
		private readonly StringAcceptor _string;
		private readonly NumberAcceptor _number;
		private readonly BooleanAcceptor _boolean;
		private readonly NullAcceptor _null;
		private readonly ArrayAcceptor _array;
		private readonly ObjectAcceptor _object;
		private readonly AlsoAcceptor[] _also;

		public string Id { get { return _id; } }
		public StringAcceptor String { get { return _string; } }
		public NumberAcceptor Number { get { return _number; } }
		public BooleanAcceptor Boolean { get { return _boolean; } }
		public NullAcceptor Null { get { return _null; } }
		public ArrayAcceptor Array { get { return _array; } }
		public ObjectAcceptor Object { get { return _object; } }
		public AlsoAcceptor[] Also { get { return _also; } }

		public ValueAcceptor(string id, StringAcceptor string_, NumberAcceptor number, BooleanAcceptor boolean_, NullAcceptor null_, ArrayAcceptor array, ObjectAcceptor object_, AlsoAcceptor[] also)
		{
			_id = id;
			_string = string_;
			_number = number;
			_boolean = boolean_;
			_null = null_;
			_array = array;
			_object = object_;
			_also = also;
		}
	}

	public enum Validity
	{
		Valid,
		Invalid
	}

	public class ValidationInfo
	{
		private Validity _validity;
		private readonly Dictionary<string, object> _schemas = new Dictionary<string, object>();

		public bool IsValid { get { return _validity == Validity.Valid; } }

		public bool IsA(string schema)
		{
			return _schemas.ContainsKey(schema);
		}

		public ValidationInfo(Validity validity) { _validity = validity; }

		public ValidationInfo(string schema) { _validity = Validity.Valid; _schemas.Add(schema, null); }

		public void AddSchema(string schema) { if (!_schemas.ContainsKey(schema)) _schemas.Add(schema, null); }

		public void Merge(ValidationInfo other)
		{
			if (_validity == Validity.Invalid || other._validity == Validity.Invalid)
			{
				_validity = Validity.Invalid;
				_schemas.Clear();
			}
			else
			{
				foreach (var key in other._schemas.Keys)
					if (!_schemas.ContainsKey(key))
						_schemas.Add(key, null);
			}
		}

		public Validity Validity { get { return _validity; } }
	}


	public class Parser
	{
		struct State
		{
			public System.IO.TextReader Reader;
			public int Current;
			private readonly bool Json5;

			public State(System.IO.TextReader reader, int current, bool json5)
			{
				Reader = reader;
				Current = current;
				Json5 = json5;
			}

			public void Skip()
			{
				Current = Reader.Read();
			}

			public void SkipWS()
			{
				while (Current != -1 && char.IsWhiteSpace((char)Current))
					Current = Reader.Read();
			}

			Array ParseArray()
			{
				Skip(); 
				SkipWS();
				if (Current == ']')
				{
					Skip();
					return new Array(new Value[0]);
				}
				List<Value> content = new List<Value>();
				while (true)
				{
					content.Add(Parse());
					SkipWS();
					if (Current == ',')
					{
						Skip();
						continue;
					}
					if (Current == ']')
						break;
					throw new InvalidOperationException("Invalid array syntax.");
				}
				Skip();
				return new Array(content.ToArray());
			}

			Array ParseArrayJson5()
			{
				Skip();
				SkipWS();
				List<Value> content = new List<Value>();
				while (true)
				{
					if (Current == ']') break;
					content.Add(Parse());
					SkipWS();
					if (Current == ',')
					{
						Skip();
						SkipWS();
					}
					else if (Current != ']') throw new InvalidOperationException("Invalid array syntax."); 
				}
				Skip();
				return new Array(content.ToArray());
			}

			int XD()
			{
				var c = Current;
				Skip();
				if (c >= '0' && c <= '9')
					return c - '0';
				if (c >= 'A' && c <= 'F')
					return (c - 'A') + 10;
				if (c >= 'a' && c <= 'f')
					return (c - 'a') + 10;
				throw new InvalidOperationException("Invalid hex digit.");
			}

			string ParseStringLiteral()
			{
				if (Current != '"')
					throw new InvalidOperationException("JSON: Expected a string.");
				Skip();

				var sb = new System.Text.StringBuilder();
				while (true)
				{
					if (Current == -1) throw new InvalidOperationException("JSON: Expected closing quote.");
					if (Current == '"') break;
					if (Current == '\\')
					{
						Skip();
						switch (Current)
						{
							case '/': { sb.Append('/'); Skip(); } break;
							case 'b': { sb.Append('\b'); Skip(); } break;
							case 'f': { sb.Append('\f'); Skip(); } break;
							case 'r': { sb.Append('\r'); Skip(); } break;
							case 't': { sb.Append('\t'); Skip(); } break;
							case 'n': { sb.Append('\n'); Skip(); } break;
							case '\\': { sb.Append('\\'); Skip(); } break;
							case '"': { sb.Append('"'); Skip(); } break;
							case '\'': { sb.Append("\'"); Skip(); } break;
							case 'u':
								{
									Skip();
									var a = XD();
									var b = XD();
									var c = XD();
									var d = XD();
									sb.Append((char)(d + 16 * c + 256 * b + 4096 * a));
								}
								break;
							default:
								throw new InvalidOperationException("JSON: Invalid escape sequence.");
						}
					}
					else
					{
						sb.Append((char)Current);
						Skip();
					}
				}
				Skip();

				return sb.ToString();
			}

			string ParseKeyword()
			{
				System.Text.StringBuilder bld = new System.Text.StringBuilder();
				bld.Append((char)Current);
				Skip();
				while (Current != -1 && char.IsLetterOrDigit((char)Current))
				{
					bld.Append((char)Current);
					Skip();
				}
				return bld.ToString();
			}

			string ParseStringOrKeyword()
			{
				if (Current == '"') return ParseStringLiteral();
				if (Current != -1 && char.IsLetter((char)Current))
					return ParseKeyword();
				throw new InvalidOperationException("JSON: Invalid object member key.");
			}

			Primitive ParseString()
			{
				return new Primitive(Type.String, ParseStringLiteral());
			}

			void CheckKeyword(string keyword)
			{
				Skip(); // first character matched outside.
				for (int i = 1; i != keyword.Length; ++i)
				{
					if (Current != keyword[i])
						throw new InvalidOperationException("JSON: Invalid keyword.");
					Skip();
				}
				if (Current != -1 && char.IsLetterOrDigit((char)Current))
					throw new InvalidOperationException("JSON: Invalid keyword.");
			}

			Primitive ParseTrue()
			{
				CheckKeyword("true");
				return new Primitive(Type.Boolean, "true");
			}

			Primitive ParseFalse()
			{
				CheckKeyword("false");
				return new Primitive(Type.Boolean, "false");
			}
			Primitive ParseNull()
			{
				CheckKeyword("null");
				return new Primitive(Type.Null, "null");
			}
			Primitive ParseNumber()
			{
				System.Text.StringBuilder bld = new System.Text.StringBuilder();
				if (Current == '-')
				{
					bld.Append('-');
					Skip();
				}
				if (Current == '0')
				{
					bld.Append('0');
					Skip();
					if (Current >= '0' && Current <= '9') throw new InvalidOperationException("Invalid number literal.");
				}
				else if (Current >= '1'&& Current <= '9')
				{
					bld.Append((char)Current);
					Skip();
					while (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
					}
				}
				else throw new InvalidOperationException("Invalid number literal.");

				if (Current == '.')
				{
					bld.Append('.');
					Skip();
					if (!(Current >= '0' && Current <= '9')) throw new InvalidOperationException("Invalid number literal.");
					bld.Append((char)Current);
					Skip();
					while (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
					}
				}

				if (Current == 'e' || Current == 'E')
				{
					bld.Append((char)Current);
					Skip();
					if (Current == '+' || Current == '-')
					{
						bld.Append((char)Current);
						Skip();
					}
					if (!(Current >= '0' && Current <= '9')) throw new InvalidOperationException("Invalid number literal.");
					bld.Append((char)Current);
					Skip();
					while (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
					}
				}

				if (Current != -1 && char.IsLetterOrDigit((char)Current)) throw new InvalidOperationException("Invalid number literal.");

				return new Primitive(Type.Number, bld.ToString());
			}

			string ParseXN()
			{
				System.Text.StringBuilder bld = new System.Text.StringBuilder();
				while ((Current >= '0' && Current <= '9') ||
					(Current >= 'A' && Current <= 'F') ||
					(Current >= 'a' && Current <= 'f'))
				{
					bld.Append((char)Current);
					Skip();
				}
				return long.Parse(bld.ToString(), System.Globalization.NumberStyles.HexNumber).ToString(System.Globalization.CultureInfo.InvariantCulture);
			}

			Primitive ParseNumberJson5()
			{
				System.Text.StringBuilder bld = new System.Text.StringBuilder();
				if (Current == '-')
				{
					bld.Append('-');
					Skip();
				}
				else if (Current == '+')
				{
					Skip();
				}
				if (Current == 'I')
				{
					CheckKeyword("Infinity");
					bld.Append("Infinity");
					return new Primitive(Type.Number, bld.ToString());
				}
				if (Current == 'N')
				{
					CheckKeyword("NaN");
					return new Primitive(Type.Number, "NaN");
				}

				if (Current == '0')
				{
					Skip();
					if (Current == 'x')
					{
						Skip();
						bld.Append(ParseXN());
						return new Primitive(Type.Number, bld.ToString());
					}
					if (Current != -1 && Current != '.' && Current != 'e' && Current != 'E') throw new InvalidOperationException("Invalid number literal.");
					bld.Append('0');
				}
				else if (Current >= '1' && Current <= '9')
				{
					bld.Append((char)Current);
					Skip();
					while (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
					}
				}
				else if (Current != '.') throw new InvalidOperationException("Invalid number literal.");
				else bld.Append('0');

				if (Current == '.')
				{
					Skip();
					bld.Append('.');
					bool norm = true;
					while (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
						norm = false;
					}
					if (norm) bld.Append('0');
				}
				if (Current == 'e' || Current == 'E')
				{
					bld.Append((char)Current);
					Skip();
					if (Current == '+' || Current == '-')
					{
						bld.Append((char)Current);
						Skip();
					}
					if (Current >= '0' && Current <= '9')
					{
						bld.Append((char)Current);
						Skip();
						while (Current >= '0' && Current <= '9')
						{
							bld.Append((char)Current);
							Skip();
						}
					}
					else
						throw new InvalidOperationException("Invalid number literal.");
				}
				return new Primitive(Type.Number, bld.ToString());
			}

			public Object ParseObject()
			{
				Skip(); // '{'
				SkipWS();
				if (Current == '}')
				{
					Skip();
					return new Object(new Member[0]);
				}
				List<Member> content = new List<Member>();
				while (true)
				{
					string key = ParseStringLiteral();
					SkipWS();
					if (Current != ':') throw new InvalidOperationException("Invalid object syntax.");
					Skip();
					var value = Parse();
					content.Add(new Member(key, value));
					SkipWS();
					if (Current == ',')
					{
						Skip();
						SkipWS();
						continue;
					}
					if (Current == '}')
						break;
					throw new InvalidOperationException("Invalid object syntax.");
				}
				Skip();
				return new Object(content.ToArray());
			}

			public Object ParseObjectJson5()
			{
				Skip(); // '{'
				SkipWS();
				List<Member> content = new List<Member>();
				while (true)
				{
					if (Current == '}') break;
					string key = ParseStringOrKeyword();
					SkipWS();
					if (Current != ':') throw new InvalidOperationException("Invalid object syntax.");
					Skip();
					var value = Parse();
					content.Add(new Member(key, value));
					SkipWS();
					if (Current == ',')
					{
						Skip();
						SkipWS();
					}
					else if (Current != '}')
						throw new InvalidOperationException("Invalid object syntax.");
				}
				Skip();
				return new Object(content.ToArray());
			}

			public Value Parse()
			{
				SkipWS();
				if (Json5)
				{
					switch (Current)
					{
						case '"': return ParseString();
						case '0':
						case '-':
						case '+':
						case 'I':
						case 'N':
						case '.':
						case '1': case '2': case '3': case '4':
						case '5': case '6': case '7': case '8': case '9':
							return ParseNumberJson5();
						case 't': return ParseTrue();
						case 'f': return ParseFalse();
						case 'n': return ParseNull();
						case '[': return ParseArrayJson5();
						case '{': return ParseObjectJson5();
						default: throw new InvalidOperationException("Unexpected character in JSON input.");
					}
				}
				else
				{
					switch (Current)
					{
						case '"': return ParseString();
						case '0': case '1': case '2': case '3': case '4':
						case '5': case '6': case '7': case '8': case '9':
						case '-': return ParseNumber();
						case 't': return ParseTrue();
						case 'f': return ParseFalse();
						case 'n': return ParseNull();
						case '[': return ParseArray();
						case '{': return ParseObject();
						default: throw new InvalidOperationException("Unexpected character in JSON input.");
					}
				}
			}
		}



		public static Value Parse(System.IO.TextReader source, bool json5, bool jsonLines)
		{
			var state = new State(source, source.Read(), json5);
			if (jsonLines)
			{
				List<Value> content = new List<Value>();
				do
				{
					content.Add(state.Parse());
					state.SkipWS();
				}
				while (state.Current != -1);

				return new Array(content.ToArray());
			}
			else
			{
				var res = state.Parse();
				state.SkipWS();
				if (state.Current != -1)
					throw new InvalidOperationException("Not well-formed JSON.");
				return res;
			}
		}
	}

}
